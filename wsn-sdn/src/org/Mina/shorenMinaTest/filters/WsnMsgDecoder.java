/**
 * @author shoren
 * @date 2013-6-5
 */
package org.Mina.shorenMinaTest.filters;

import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;

import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.session.AttributeKey;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.ProtocolDecoderAdapter;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.Mina.shorenMinaTest.msg.WsnMsg;


/**
 *
 */
public class WsnMsgDecoder extends ProtocolDecoderAdapter{

	private final Charset charset;
	private final AttributeKey CONTEXT = new AttributeKey(getClass(),"context");
	private int maxPackLength = 10000;
	
	
	public WsnMsgDecoder(Charset charset){
		this.charset = charset;
	}
	
	/**
	 * 解析包的前两条信息，类名及内容长度.通过类名得到信息的实例，根据长度值，读取所有的信息内容。
	 * 然后调用实例的StringToMsg方法（默认是调用MinaUtil中的使用反射的方法），为实例的各个域赋值。
	 * 怎么读字节流找边界呢？？？？？？？？？
	 * */
	@Override
	public void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {
//		System.out.println("enter in WsnMsgDecoder");  
		
		final int packHeadLength = 4;     
	        //先获取上次的处理上下文，其中可能有未处理完的数据     
	        Context ctx = getContext(session);     
	        // 先把当前buffer中的数据追加到Context的buffer当中      
	        ctx.append(in);      
	        //把position指向0位置，把limit指向原来的position位置     
	        IoBuffer buf = ctx.getBuffer();  	        
	        buf.flip();  

	        // 然后按数据包的协议进行读取     
	        while (buf.remaining() >= packHeadLength) {     
	            buf.mark();     
	            // 读取消息头部分     
	            int length = buf.getInt();     //nice  
	             
	            //检查读取的包头是否正常，不正常的话清空buffer     
	            if (length<0 ||length > maxPackLength) {     
	                buf.clear();      
	                break;     
	            }      
	            //读取正常的消息包，并写入输出流中，以便IoHandler进行处理     
	            else if (length <= buf.remaining()) {   //length表示的是后面内容的长度   
	                int oldLimit2 = buf.limit();     
	                buf.limit(buf.position() + length);     
	                String content = buf.getString(ctx.getDecoder());     
	                buf.limit(oldLimit2);     
//	                System.out.println(content); //logger record it
	                if(content.contains("className=")){
	                	//生成消息实例
		                int index1 = content.indexOf("=");
		                int index2 = content.indexOf(";");
		                String className = content.substring(index1+1, index2);
		                content = content.substring(index2+1);  //消息类容
		                
		                WsnMsg msg = (WsnMsg) Class.forName(className).newInstance(); //得到实例
		                
		                if(content!=null && content != "" && content.length() != 0){
		                	msg.stringToMsg(content);  //为各个域赋值
		                }		                	
		                out.write(msg);       //写入通道
	                }else{
	                	out.write(content);
	                }
	                	
	               
	            } else {     
	                // 如果消息包不完整     
	                // 将指针重新移动消息头的起始位置      
	                buf.reset();      
	                break;     
	            }     
	        }     
	        if (buf.hasRemaining()) {     
	            // 将数据移到buffer的最前面      
	                IoBuffer temp = IoBuffer.allocate(maxPackLength).setAutoExpand(true);     
	                temp.put(buf);     
	                temp.flip();     
	                buf.clear();     
	                buf.put(temp);    
	        //        String con = buf.getString(ctx.getDecoder());
	                      
	        } else {// 如果数据已经处理完毕，进行清空     
	            buf.clear();      
	        } 
		
		
	}
	
	 
	/**
	 * 记录上下文，因为数据触发没有规模，很可能只收到数据包的一半.	所以，需要上下文拼起来才能完整的处理 .	
	*/
	private Context getContext(IoSession session) {
		Context context = (Context) session.getAttribute(CONTEXT);
		if (context == null) {
			context = new Context();
			session.setAttribute(CONTEXT, context);
		}
		return context;
	}
	
	private class Context {
		private final IoBuffer innerBuffer;
		private String sms = "";
		private int matchCount = 0;
		private final CharsetDecoder decoder; 
		
		
		public Context() {
			decoder = charset.newDecoder();
			innerBuffer = IoBuffer.allocate(100).setAutoExpand(true);
		}
		
		public CharsetDecoder getDecoder() {  
            return decoder;  
        }
		
		public int getMatchCount() {
			return matchCount;
		}

		public void setMatchCount(int matchCount) {
			this.matchCount = matchCount;
		}

		public void reset() {
			this.innerBuffer.clear();
			this.matchCount = 0;
			this.sms = "";
		}
		
		public IoBuffer getBuffer(){
			return innerBuffer;
		}
		
		public void append(IoBuffer in) {   
            getBuffer().put(in);              
        }
	}

}
